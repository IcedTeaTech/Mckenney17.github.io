const $_SwipeJS = (a) => ((a) => {
 if (!a || !a.addEventListener) throw new TypeError("You might wanna re-check the element argument it's invalid"); const b = ['swipeup', 'swipedown', 'swipeleft', 'swiperight']; const c = () => new Promise((b) => {
 let c = 0; let d = 0; let e = 0; let f = 0; let g = 0; let h = 0; let i = 0; const j = () => { c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0; }; const k = (a) => { c = a.touches[0].clientX, d = a.touches[0].clientY; }; const l = (a, b) => { if (i > b) return; const j = a.touches[0].clientX; const k = a.touches[0].clientY; j > c ? e = j : j < c && (f = j), k > d ? g = k : k < d && (h = k); }; const m = () => {
 const a = {
 swipePosX: e, swipePosY: g, swipeNegX: f, swipeNegY: h,
}; const b = {}; const i = {}; const k = {}; for (const c in a)a[c] !== 0 && (b[c] = a[c]); const l = Object.keys(b).filter((a) => a.endsWith('X')); const m = Object.keys(b).filter((a) => a.endsWith('Y')); const n = [l, m].filter((a) => a.length === 2)[0]; const o = (a) => { const c = b[a[0]]; const d = b[a[1]]; const e = Math.min(c, d); return e === c ? a[0] : a[1]; }; let p = ''; for (const a in n && (p = o(n)), b)a !== p && (i[a] = b[a]); for (const a in i)a.endsWith('X') && a.includes('Pos') ? k[`${a}By`] = i[a] - c : a.endsWith('Y') && a.includes('Pos') ? k[`${a}By`] = i[a] - d : a.endsWith('X') && a.includes('Neg') ? k[`${a}By`] = c - i[a] : a.endsWith('Y') && a.includes('Neg') && (k[`${a}By`] = d - i[a]); const q = (a) => { const [b, c] = Object.keys(a); const [d, e] = [a[b], a[c]]; const f = Math.max(d, e); return f === d ? b : c; }; if (j(), Object.keys(k).length === 2) { const a = q(k); switch (a) { case 'swipePosXBy': return 'swiperight'; case 'swipeNegXBy': return 'swipeleft'; case 'swipePosYBy': return 'swipedown'; case 'swipeNegYBy': return 'swipeup'; default: } } else if (Object.keys(k).length === 1) { const [a] = Object.keys(k); switch (a) { case 'swipePosXBy': return 'swiperight'; case 'swipeNegXBy': return 'swipeleft'; case 'swipePosYBy': return 'swipedown'; case 'swipeNegYBy': return 'swipeup'; default: } } return null;
}; a.addEventListener('touchmove', (a) => { i++, l(a, 3); }), a.addEventListener('touchstart', (a) => { k(a); }), a.addEventListener('touchend', () => { b(m()); });
}); return { async addSwipeListener(a, d) { try { if (typeof a !== 'string') throw new TypeError("You might wanna check your swipe type... Maybe it's not even a string at all."); if (!b.includes(a)) throw new TypeError("What could be wrong? Hmmm... You probably mispelt your swipe type. Confirm it's one of swipe(up|down|left|right) e.g. swipeup, :-) you're welcome"); if (typeof d !== 'function') throw new TypeError('Are you sure your callback is a function at all???'); } catch (a) { console.error(a); } for (;;) { const b = await c(); a === b && d("Let me know why you'll need an event argument on GitHub"); } } };
})(a); export default $_SwipeJS;
